<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Página técnica - Noelia F.</title>
    <link rel="icon" type="image/x-icon"
        href="http://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/b2b4c5430309cac.png">
    <link rel="stylesheet" href="style.css">
    <script>
        const projectName = "technical-page";
        localStorage.setItem("proyecto_es6", "Página JS ES6");

    </script>
</head>

<body>


    <nav id="navbar">
        <header id="title-nav">
            JavaScript Terms
            <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
        </header>
        <ul>
            <a class="nav-link" href="#introduccion_es6" rel="internal">
                <li>Introducción a ES6</li>
            </a>
            <a class="nav-link" href="#variables" rel="internal">
                <li>Variables</li>
            </a>
            <a class="nav-link" href="#funcion_flecha" rel="internal">
                <li>Funciones con dirección (flecha)</li>
            </a>
            <a class="nav-link" href="#plantilla_literales" rel="internal">
                <li>Plantillas literales (cadenas)</li>
            </a>
            <a class="nav-link" href="#parametros_def" rel="internal">
                <li>Parámetros por defecto</li>
            </a>
            <a class="nav-link" href="#des_arrays" rel="internal">
                <li>Desestructuración de arrays y objetos</li>
            </a>
            <a class="nav-link" href="#import_y_export" rel="internal">
                <li>Import and export</li>
            </a>
            <a class="nav-link" href="#promise" rel="internal">
                <li>Concepto Promise</li>
            </a>
            <a class="nav-link" href="#rest_y_spread" rel="internal">
                <li>Spread Operator y Rest Parameter</li>
            </a>
            <a class="nav-link" href="#clases" rel="internal">
                <li>Clases</li>
            </a>
        </ul>
    </nav>
    <main id="main-doc">
        <section class="main-section" id="introduccion_es6">
            <header>Introducción a ES6</header>
            <article>
                <p>JavaScript ES6 trae nueva sintaxis y nuevas funciones increíbles para hacer que su código sea más
                    legible y moderno. Le permite escribir menos código y mucho más. ES6 nos presenta excelentes
                    características como la función de flecha, plantillas de cadenas, desestructurar clases, módulos y
                    más.</p>
            </article>
        </section>
        <section class="main-section" id="variables">
            <header>Var,let y const</header>
            <article>
                <p>En ES6 ya tenemos varias formas de declarar nuestras variables. En ES5 lo hacíamos con la palabra
                    var, pero ahora hay dos más.</p>
                <p>El problema de var es el scope que genera, es decir el ámbito que crea para la variable en cuestión.
                </p>
                <p> Por lo tanto, se recomienda dejar de usar vary de esta forma, reemplazarla por <strong>let y
                        const</strong>.</p>
                <p>La principal diferencia entre let y const es que let todavía se puede reasignar pero const no, lo que
                    hace que const sea una variable inmutable. Aquí vemos unos ejemplos:</p>

                <code>function x() {
    var a = 0;
  }
  //console.log(a) //No va a funcionar. 
  </code>
                <code> for (let i = 10; i > 0; i--) {
       console.log(i);              
  }
  console.log(i);
  // Esa línea funcionará porque var solo tiene un alcance en la función.
  </code>
                <p>Para let y const:</p>
                <code>let b = 1;
      b = 2;
  const c = 1;
        c = 2; // Esta línea no funcionará, pero a su vez mostrará ambas "funcionando".
  </code>
            </article>
        </section>
        <section class="main-section" id="funcion_flecha">
            <header>Funciones tipo flecha</header>
            <article>
                <p>Las funciones de flecha se ven ordenadas y hacen que tu código sea mucho más legible, estructurado y
                    moderno.
                    En lugar de esto:
                </p>
                <code>function hello(name) {
    return "Hello " + name;
  }</code>
                <p>Puedes hacer esto:</p>
                <code>const hello = name => "Hello " + name;</code>
                <p>Con las funciones de flecha puedes usarlo con el mapa, funciones filter y reducir las funciones
                    integradas.</p>
            </article>
        </section>
        <section class="main-section" id="plantilla_literales">
            <header>Plantillas literales (cadenas)</header>
            <article>
                <p>Los literales de plantilla o las cadenas de plantilla son estupendas. No tenemos que usar el operador
                    (+) para
                    concatenar cadenas, o cuando queremos una variable dentro de una cadena.</p>
                <p>Sintaxis anterior</p>
                <code>function myFunc1(name, age) {
    return 'Hola ' + name + ' tienes ' + age + ' años';
  }
  console.log(myFun1('Artem', 26));
  //El output será: "Hola Artem, tienes 26 años.";
  </code>
                <p>Con la sintaxis del ES6:</p>
                <code>const myFunc = (name, age) = {
    return `Hola ${name}, tienes ${age} años;
  }
  console.log(myFunc(Artem, 26))
  //El output será: "Hola Artem, tienes 26 años.";
  </code>
            </article>
        </section>
        <section class="main-section" id="parametros_def">
            <header>Parámetros por defecto</header>
            <article>
                <p>Los parámetros predeterminados son parámetros que tienen una asignación asignada entre paréntesis si
                    el usuario
                    no da una entrada para ese parámetro. Ejemplo:</p>
                <code>const myFunc = (name, age=2) => {
    return `Hola ${name} tienes ${age} años`;
  }
  console.log(myFun(DatePepe))
  //Output "Hola Datepepe tienes 2 años.";
  </code>
                <p>Como puedes ver, la función devuelve un valor aunque nos perdimos el segundo parámetro. Ahora con el
                    parámetro predeterminado podemos manejar el error por adelantado.</p>
            </article>
        </section>
        <section class="main-section" id="des_arrays">
            <header>Desestructuración de matrices y objetos.</header>
            <article>
                <p>La desestructuración facilita la asignación de los valores de una matriz u objeto a la nueva
                    variable.</p>
                <p>Sintaxis anterior:</p>
                <code>const contacto={
    nombre: 'Noelia',
    apellido: 'Fernandez',
    edad: 21
  }
  let nombre = contacto.nombre;
  let apellido = contacto.apellido;
  let age = contacto.edad;
  </code>
                <p>Con la sintaxis de ES6:</p>
                <code>const contacto={
    nombre: 'Noelia',
    apellido: 'Fernandez',
    edad: 21
  }
  let{nombre, apellido, edad} = contacto;
  console.log(nombre);
  console.log(apellido);
  console.log(edad);
  </code>
                <p>Con ES5, tenemos que asignar cada valor a cada variable. Con ES6, simplemente ponemos nuestros
                    valores dentro
                    corchetes para obtener cualquier propiedad del objeto.</p>
                <p>Nota: si asigna una variable que no es idéntica al nombre de la propiedad, devolverá
                    indefinido. Por ejemplo, si el nombre de la propiedad es nombre y lo asignamos a una variable de
                    nombre de usuario,
                    volverá indefinido.</p>
                <p>Siempre tenemos que nombrar la variable igual que el nombre de la propiedad. Pero en caso de que
                    queramos
                    cambie el nombre de la variable, podemos usar los dos puntos : en su lugar.</p>
                <code>const contacto= {
                nombre: "Noelia",
                apellido: "Fernandez",
                edad: 21
            }
            </code>
                <p>Para la matriz, usamos la misma sintaxis que el objeto. Solo tenemos que reemplazar los corchetes con
                    corchetes.</p>
                <code>const Arr=['Pepe', 'María', 'Manu', 20];
                    let [value1, value2, value3, value4] = Arr;
                    console.log(value1) // 'Lionel';
                </code>
            </article>
        </section>
        <section class="main-section" id="import_y_export">
            <header>Import and export</header>
            <article>
                <p>El uso de la importación y exportación en su aplicación JavaScript la hace más poderosa. te permiten
                    crear componentes separados y reutilizables.</p>
                <p>Si está familiarizado con cualquier framework MVC de JavaScript, verás que usan importación y
                    exportación
                    manejar los componentes la mayor parte del tiempo. Entonces, ¿cómo funcionan realmente?</p>
                <p>¡Es simple! Export te permite exportar un módulo para usarlo en otro componente de JavaScript. Usamos
                    import para importar ese módulo y así usarlo en nuestro componente.</p>
                <p>Por ejemplo, tenemos dos archivos. El primero se llama detailComponent.js y el segundo se llama
                    homeComponent.js.</p>
                <p>En detailComponent.js vamos a exportar la función detail.</p>
                <code>export default function detail(name, age) {
    return `Hola ${name}, tienes ${age} años.`;
  }
  </code>
                <p>Y si queremos usar esta función en homeComponent.js, solo usaremos import.</p>
                <code>import detail from './detailComponent'
  console.log(detail('Artem', 26));
  //output 'Hola Artem, tienes 26 años.';
  </code>
                <p>Si queremos importar más de un módulo, simplemente los ponemos entre llaves.</p>
                <code>import {detail, userProfile, getPosts} from './detailComponent'
  </code>
            </article>
        </section>

        <section class="main-section" id="promise">
            <header>Concepto promise</header>
            <article>
                <p>Las promesas son una nueva característica de ES6. Es un método para escribir código asíncrono. Puede
                    utilizarse cuando, por
                    ejemplo, queremos obtener datos de una API, o cuando tenemos una función que toma tiempo para ser
                    ejecutada. Las promesas facilitan la resolución del problema, ¡así que creemos nuestra primera
                    Promesa!</p>
                <code>const myPromise = () => {
    return new Promise((resolve, reject)=> {
      resolve('Hola, promise se ejecuta bien:)')
    })
  }
  </code>
                <p>Si inicias sesión en tu consola, devolverá una función Promise. Entonces, si queremos ejecutar una
                    función después de que los datos estén
                    obtenido, usaremos una Promesa. Promise toma dos parámetros: resolve y reject para manejar una
                    error esperado.</p>
                <p>Nota: la función de búsqueda fetch devuelve una función Promise en sí misma.</p>
                <code>const url='https://jsonplaceholder.typicode.com/posts';
  const getData=(url)=>{
    return fetch(url);
  }
  getData(url).
  then(data=> data.json()).
  then(result=> console.log(result));
  </code>
                <p>Ahora, si inicias sesión en tu consola, devolverá una serie de datos.</p>
            </article>
        </section>
        <section class="main-section" id="rest_y_spread">
            <header>El operador spread y el parámetro rest</header>
            <article>
                <p>El resto de parámetros se utilizan para obtener el argumento de una matriz y devolver una nueva
                    matriz.</p>
                <p>Los Rest Parameters, son representados mediante tres puntos consecutivos, pero
                    distan bastante de parecerse al Spread Operator. Su funcionalidad es la de unir distintos elementos
                    a un arreglo.
                    Normalmente se puede ver en los argumentos de una función.</p>
                <code>const arr=['said', 'words', 'hello', 'world', 'monkey'];
  const [val1, val2, val3, ...rest]=arr;
  const Func=(restOfArr)=> {
    return restOfArr.filter(item=>{return item}).join(" ");
  }
  console.log(Func(rest));
  </code>
                <code>const arr=['Dijo',20,'JavaScript fan','Hola','Dijo','Cómo te va?'];
  const Func(...array) {
    return array
  }
  console.log(Func(arr));
  //'Dijo',20,'JavaScript fan','Hola','Dijo','Cómo te va?']
  </code>
                <p>El operador spread tiene la misma sintaxis que el parámetro rest, pero spread toma el
                    Array en sí mismo y no solo los argumentos. Podemos usar el parámetro Spread para obtener los
                    valores de un
                    Array, en lugar de usar un bucle for o cualquier otro método.</p>
                <p>Corresponde a un operador el cuál distribuye los elementos de un arreglo u objeto, para asignarlos a
                    alguna variable/constante/función.</p>
                <code>const arr=['Dijo',20,'JavaScript fan','Hola','Dijo','Cómo te va?'];
  const Func=(...anArray)=>{
    return anArray;
  }
  console.log(Func(arr));
  //output  ['Dijo',20,'JavaScript fan','Hola','Dijo','Cómo te va?']
  </code>
            </article>
        </section>
        <section class="main-section" id="clases">
            <header>Clases</header>
            <article>
                <p>Las clases son el núcleo de la programación orientada a objetos (POO). Hacen que tu código sea más
                    seguro y
                    encapsulado. El uso de clases le da a tu código una buena estructura y lo mantiene ordenado.</p>
                <p>Para crear una clase, use la palabra clave class seguida del nombre de la clase con dos corchetes.
                </p>
                <code>class nuevaClase {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }
  const user = new nuevaClase("Noelia", 21);
  console.log(user.name) // "Noelia"
  console.log(user.age) // 21
  </code>
                <p>Ahora podemos acceder a los métodos y propiedades de la clase usando la nueva palabra clave:</p>
                <code>class nuevaClase{
    constructor(name,age){
    this.name=name;
    this.age=age;
    }
  }
  const Home= new nuevaClase("Dijo",21);
  console.log(Home.name) //  Dijo
  </code>
                <p>Para heredar de otra clase, usa la palabra clave extends seguida del nombre de la clase que desea
                    heredar.</p>
                <code>class nuevaClase {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
    sayHello() {
      console.log(`Hi your name is ${name} and your ${age} years old!`);
    }
  }
  //inherit nuevaClase methods and properties
  class userProfile extends myClass {
    userName() {
      console.log(this.name);
    }
  }
        
  const profile = new userProfile("Jake", 17);
  profile.sayHello() // "Hi your name is Jake and your 17 years old!"
  profile.userName() // "Jake"
  </code>
                <p>ES6 tiene otras características sorprendentes. Aquí hay algunas de ellas:</p>
                <ul>
                    <li>Literales extendidos</li>
                    <li>Expresiones regulares mejoradas</li>
                    <li>Tipo de símbolo</li>
                    <li>Iteradores</li>
                    <li>Generadores</li>
                    <li>Mapa/Conjunto y Mapa débil/Conjunto débil</li>
                    <li>Metaprogramación</li>
                </ul>

                <form action="http://es6-features.org/#Constants">
                    <input type="submit" class="button-33" value="Click aquí para leer más sobre ES6" />
                </form>
            </article>
        </section>
    </main>

</body>

</html>